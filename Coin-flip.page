---
title: The Kelly Coin-Flipping Game: Exact Solutions via Dynamic Programming
description: Decision-theoretic analysis of how to optimally play Haghani & Dewey 2016's double-or-nothing coin-flipping game with an edge and ceiling better than using the Kelly Criterion. Computing and following an exact decision tree increases earnings by \$6.6 over a modified KC.
tags: statistics, decision theory, Haskell
created: 19 Jan 2017
status: finished
belief: likely
...

> Haghani & Dewey 2016 experiment with a double-or-nothing coin-flipping game where the player starts with \$25 and has an edge of 60%, and can play 300 times, choosing how much to bet each time, winning up to a maximum ceiling of \$250. Most of their subjects fail to play well, earning an average \$91, compared to Haghani & Dewey 2016's heuristic benchmark of ~\$240 in winnings achievable using a modified Kelly Criterion for playing. The KC, however, is not optimal for this problem as it ignores the ceiling and limited number of plays. We solve the problem of the value of optimal play exactly by using decision trees & dynamic programming in R & Haskell, finding that optimal play yields \$246.61 on average (rather than ~\$240), and so the human players actually earned only 36.8% of what was possible, losing \$155.6. The relative advantage of the decision tree strategy depends on the number of bets: it is highest when the player can make few bets, and decreases with number of bets as more strategies hit the ceiling.

# Background
## Set up

The paper ["Rational Decision-Making Under Uncertainty: Observed Betting Patterns on a Biased Coin"](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2856963), by Haghani & Dewey 2016 runs an economics/psychology experiment on optimal betting in a simple coin-flipping game:

> What would you do if you were invited to play a game where you were given \$25 and allowed to place bets for 30 minutes on a coin that you were told was biased to come up heads 60% of the time? This is exactly what we did, gathering 61 young, quantitatively trained men and women to play this game. The results, in a nutshell, were that the majority of these 61 players didn't place their bets very well, displaying a broad panoply of behavioral and cognitive biases. About 30% of the subjects actually went bust, losing their full \$25 stake. We also discuss optimal betting strategies, valuation of the opportunity to play the game and its similarities to investing in the stock market. The main implication of our study is that people need to be better educated and trained in how to approach decision making under uncertainty. If these quantitatively trained players, playing the simplest game we can think of involving uncertainty and favourable odds, didn't play well, what hope is there for the rest of us when it comes to playing the biggest and most important game of all: investing our savings? In the words of [Ed Thorp](!Wikipedia "Edward O. Thorp"), who gave us helpful feedback on our research: "This is a great experiment for many reasons. It ought to become part of the basic education of anyone interested in finance or gambling."

More specifically:

> ...Prior to starting the game, participants read a detailed description of the game, which included a clear statement, in bold, indicating that the simulated coin had a 60% chance of coming up heads and a 40% chance of coming up tails. Participants were given \$25 of starting capital and it was explained in text and verbally that they would be paid, by check, the amount of their ending balance subject to a maximum payout. The maximum payout would be revealed if and when subjects placed a bet that if successful would make their balance greater than or equal to the cap. We set the cap at \$250......Participants were told that they could play the game for 30 minutes, and if they accepted the \$25 stake, they had to remain in the room for that amount of time.^5^ Participants could place a wager of any amount in their account, in increments of \$0.01, and they could bet on heads or tails...Assuming a player with agile fingers can put down a bet every 6 seconds, that would allow 300 bets in the 30 minutes of play.

## Near-optimal play

The authors make a specific suggestion about what near-optimal play in this game would be, based on the [Kelly criterion](!Wikipedia) which would yield bets each round of 20% of capital:

> The basic idea of the Kelly formula is that a player who wants to maximize the rate of growth of his wealth should bet a constant fraction of his wealth on each flip of the coin, defined by the function $(2 \cdot p) - 1$, where $p$ is the probability of winning. The formula implicitly assumes the gambler has log utility. It's intuitive that there should be an optimal fraction to bet; if the player bets a very high fraction, he risks losing so much money on a bad run that he would not be able to recover, and if he bet too little, he would not be making the most of what is a finite opportunity to place bets at favorable odds...We present the Kelly criterion as a useful heuristic a subject could gainfully employ. It may not be the optimal approach for playing the game we presented for several reasons. The Kelly criterion is consistent with the bettor having log-utility of wealth, which is a more tolerant level of risk aversion than most people exhibit. On the other hand, the subjects of our experiment likely did not view \$25 (or even \$250) as the totality of their capital, and so they ought to be less risk averse in their approach to maximizing their harvest from the game. The fact that there is some cap on the amount the subject can win should also modify the optimal strategy...In our game, the Kelly criterion would tell the subject to bet 20% ($(2 \cdot 0.6) - 1$) of his account on heads on each flip. So, the first bet would be \$5 (20% of \$25) on heads, and if he won, then he'd bet \$6 on heads (20% of \$30), but if he lost, he'd bet \$4 on heads (20% of \$20), and so on.
>
> ...If the subject rightly assumed we wouldn't be offering a cap of more than \$1,000 per player, then a reasonable heuristic would be to bet a constant proportion of one's bank using a fraction less than the Kelly criterion, and if and when the cap is discovered, reducing the betting fraction further depending on betting time remaining to glide in safely to the maximum payout. For example, betting 10% or 15% of one's account may have been a sound starting strategy. We ran simulations on the probability of hitting the cap if the subject bet a fixed proportion of wealth of 10%, 15% and 20%, and stopping when the cap was exceeded with a successful bet. We found there to be a 95% probability that the subjects would reach the \$250 cap following any of those constant proportion betting strategies, and so the expected value of the game as it was presented (with the \$250 cap) would be just under \$240. However, if they bet 5% or 40% of their bank on each flip, the probability of exceeding the cap goes down to about 70%.

## Subjects' performance

Despite the Kelly criterion being well-known and fairly intuitive, and the game being very generous, participants did not perform well:

> The sample was largely comprised of college age students in economics and finance and young professionals at finance firms. We had 14 analyst and associate level employees at two leading asset management firms. The sample consisted of 49 males and 12 females. Our prior was that these participants should have been well prepared to play a simple game with a defined positive expected value...Only 21% of participants reached the maximum payout of \$250,^7^ well below the 95% that should have reached it given a simple constant percentage betting strategy of anywhere from 10% to 20%.^8^ We were surprised that one third of the participants wound up with less money in their account than they started with. More astounding still is the fact that 28% of participants went bust and received no payout. That a game of flipping coins with an ex-ante 60/40 winning probability produced so many subjects that lost everything is startling. The average ending bankroll of those who did not reach the maximum and who also did not go bust, which represented 51% of the sample, was \$75. While this was a tripling of their initial \$25 stake, it still represents a very sub-optimal outcome given the opportunity presented. The average payout across all subjects was \$91, letting the authors off the hook relative to the \$250 per person they'd have had to pay out had all the subjects played well.

This is troubling because the problem is so well-defined and favorable to the players, and can be seen as a microcosm of the difficulties people experience in rational betting.
(While it's true that human subjects typically perform badly initially in games like the iterated prisoner's dilemma and need time to learn, it's also true that humans only have one life to learn stock market investment during, and these subjects all should've been well-prepared to play.)

Instead of expected earnings of ~\$240, the players earned $\91 - forfeiting \$149.
However, if anything, the authors understate the underperformance, because as they correctly note, the Kelly criterion is not guaranteed to be optimal in this problem due to the potential for different utility functions (what if we simply want to maximize expected wealth, not log wealth?), the fixed number of bets & the ceiling, as the Kelly criterion tends to assume that wealth can increase without limit & there is an indefinite time horizon.

# Optimality in the coin-flipping MDP

Indeed, we can see with a simple example that KC is suboptimal in terms of maximizing expected value: what if we are given only 1 bet (_b_=1) to use our \$25 on?
If we bet 20% (or less) per the KC, then

$$0.6 \cdot (25+5) + 0.4 \cdot (25-5)= 26$$

But if we bet everything:

$$0.6 \cdot (25+25) + 0.4 \cdot (25-25) = 30$$

It's true that 40% of the time, we go bankrupt and so we couldn't play again... but there are no more plays in _b_=1 so avoiding bankruptcy boots nothing.

We can treat this coin-flipping game as a [Markov decision process](!Wikipedia).
For more possible bets, the value of a bet of a particular amount given a wealth _w_ and bets remaining _b_-1 will recursively depend on the best strategy for the two possible outcomes (weighted by probability), giving us a Bellman value equation to solve like:

$$V(w,b) = \max_{x \in [0,w]}[0.6 \cdot V(\min(w+x, 250), b-1) + 0.4 \cdot V(w-x, b-1) ]$$

To solve this equation, we can explore all possible sequences of bets and outcomes to a termination condition and reward, and then work use backwards induction, defining a decision tree which can be (reasonably) efficiently computed using memoization/[dynamic programming](!Wikipedia).

Given the problem setup, we can note a few things about the optimal strategy:

1. if the wealth ever reaches \$0, the game has effectively ended regardless of how many bets remain, because betting \$0 is the only possibility and it always returns \$0
2. similarly, if the wealth ever reaches the upper bound of \$250, the optimal strategy will effectively end the game by always betting \$0 after that regardless of how many bets remain, since it can't do better than \$250 and can only do worse.

    These two shortcuts will make the tree *much* easier to evaluate because many possible sequences of bet amounts & outcomes will quickly hit \$0 or \$250 and require no further exploration.
3. a state with more bets is always of equal or better value than fewer
3. a state with more wealth is always equal or better value than less
3. the value of 0 bets is the current wealth
4. the value of 1 bet depends on the ceiling and current wealth: whether \$250 is >2x current wealth. If the ceiling more than twice current wealth, the optimal strategy with 1 bet left is to bet everything, since that has highest EV and there's no more bets to worry about going bankrupt & missing out on.

    <!-- If there were no ceiling, one could argue that the whole problem is trivial: the choice of units becomes arbitrary, so one can convert our problem of estimating $V(w, b)$ to units where _w_=1 (so $x \cdot V(1,b)$); then one solves $V(1,b)$ to find the fixed bet amount _x_; with no ceiling to deal with, the previous logic about betting 100% applies, the fraction to bet is 1, and since this is true whatever our original _w_ or _b_... Or to put it another way: for the first bet, the highest EV bet to bet everything; the second bet can be transformed back into the first bet, so it's highest EV to bet everything there too; by induction, you always bet everything. The limited number of bets sets a limit on the earnings, but doesn't affect the strategy.

    But since there is a ceiling and one may be near or far from it given one's remaining bets, the betting has to take this into account: as the number of bets increase, the potential to hit the ceiling increases. With only a few bets, the maximum strategy doesn't risk this, but 4 bets it is possible to exceed \$250 (betting everything & winning each time). -->

## Decision tree

We can write down the value function as a mutual recursion: `f` calculates the expected value of the current step, and calls `V` to estimate the value of future steps; `V` checks for the termination conditions _w_=\$0/\$250 & _b_=0 returning current wealth as the final payoff, and if not, calls `f` on every possible action to estimate their value and returns the max...
This mutual recursion bottoms out at the termination conditions.
As defined, this is grossly inefficient as every node in the decision tree will be recalculated many times despite yielding identical deterministic, referentially transparent results.
So we need to memoize results if we want to evaluate much beyond _b_=5.

### Approximate Value function

Implemented in R:

~~~{.R}
# devtools::install_github("hadley/memoise")
library(memoise)

f <- function(x, w, b) { 0.6*mV(min(w+x,250), b-1) + 0.4*mV(w-x, b-1)}
mf <- memoise(f)
V <- function(w,b) {
    returns <- if (b>0 && w>0 && w<250) { sapply(seq(0, w, by=0.1), function(x) { mf(x,w,b) }) } else { w }
    max(returns) }
mV <- memoise(V)
## sanity checks:
mV(25, 0)
# [1] 25
mV(25, 1)
# [1] 30
mV(0, 300)
# [1] 0
~~~

Given our memoized value function `mV` we can now take a look at expected value of optimal betting for bets _b_ from 0 to 300 with the fixed starting payroll of \$25.
Memoization is no panacea, and R/[`memoise`](https://cran.r-project.org/web/packages/memoise/index.html) is slow enough that I am forced to make one change to the betting: instead of allowing bets in penny/\$0.01 increments, I approximate by only allowing bets in \$1 increments, to reduce the branching factor to a maximum of 250 possible choices each turn rather than 25000 choices.
(Some comparisons with decipenny and penny trees suggests that this makes little difference since early on the bet amounts are identical and later on being able to make <\$1 adjustments to bets yield small gains relative to total wealth; see the Haskell implementation.)

Of course, even with memoization and reducing the branching factor, it's still difficult to compute the value of the optimal strategy all the way to _b_=300 because the exponentially increasing number of strategies still need to be computed at least once.
With this R implementation, trees for up to _b_=150 can be computed with 4GB RAM & ~16h.

The value function for increasing bets:

~~~{.R}
vs <- sapply(1:150, function(b) { round(mV(25, b), digits=1) }); vs
#   [1]  30.0  36.0  43.2  45.4  48.0  53.7  54.6  57.6  61.8  62.6  66.8  68.2  70.6  74.1  75.0  79.1  79.7  82.5  84.7  86.2  89.8  90.3  93.8
#  [24]  94.5  97.0  98.8 100.3 103.2 103.9 107.2 107.6 110.3 111.4 113.3 115.2 116.4 119.0 119.6 122.4 122.9 125.3 126.2 128.1 129.5 130.8 132.8
#  [47] 133.6 136.0 136.5 138.8 139.4 141.4 142.3 143.8 145.2 146.3 148.0 148.8 150.6 151.3 153.1 153.8 155.5 156.3 157.7 158.8 159.9 161.2 162.1
#  [70] 163.6 164.2 165.8 166.4 167.9 168.5 169.9 170.7 171.8 172.8 173.7 174.8 175.6 176.8 177.5 178.7 179.3 180.5 181.1 182.3 182.9 184.0 184.7
#  [93] 185.6 186.4 187.2 188.1 188.8 189.8 190.3 191.3 191.9 192.8 193.4 194.3 194.9 195.7 196.3 197.1 197.8 198.4 199.1 199.7 200.5 201.0 201.8
# [116] 202.3 203.0 203.5 204.3 204.8 205.4 206.0 206.6 207.1 207.7 208.3 208.8 209.4 209.9 210.5 210.9 211.5 211.9 212.5 213.0 213.5 213.9 214.5
# [139] 214.9 215.4 215.8 216.3 216.8 217.2 217.6 218.0 218.5 218.9 219.3 219.7
~~~

So as the number of bets escalates, our expected payoff increases fairly quickly and we can get very close to the ceiling of \$250 with canny betting.

### Optimal next action

One is also curious what the optimal strategy *is*, not just how much we can make with the optimal strategy given a particular starting point.
As defined, I can't see how to make `mV` return the optimal choices along the way, since it has to explore all choices bottom-up and can't know what is optimal until it has popped all the way back to the root, and state can't be threaded in because that defeats the memoization.

But then I remembered the point of computing value functions: given the (memoized) value function for each state, we can then plan by simply using `V` in a greedy planning algorithm by asking, at each step, for the value of each possible action (which is memoized, so it's fast), and returning/choosing the action with the maximum value (which takes into account all the downstream effects, including our use of `V` at each future choice):


~~~{.R}
VPplan <- function(w, b) {
    if (b==0) { return (0); } else {
    returns <- sapply(seq(0, w), function(wp) { mf(wp, w, b); })
      return (which.max(returns)-1); }
 }
mVPplan <- memoise(VPplan)
## sanity checks:
mVPplan(250, 0)
# [1] 0
mVPplan(250, 1)
# [1] 0
mVPplan(25, 3)
# [1] 25
~~~

It's interesting that when _b_ is very small, we want to bet everything on our first bet, because there's not enough time to bother with recovering from losses; but as we increase _b_, the first bet will shrink & become more conservative:

~~~{.R}
firstAction <- sapply(1:150, function(b) { mVPplan(25, b) }); firstAction
#   [1] 25 25 25 10 10 18 17 18 14 14 14  9 10 11  7 11  7 10 10 10  9  6  9  7  9  8  9  8  7  8  7  8  7  8  7  8  7  7  7  7  7  6  7  6  7  6  7
#  [48]  6  6  6  6  6  6  6  6  6  6  6  6  5  6  5  6  5  6  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  4  5  4  5  4  5  4
#  [95]  5  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  3
# [142]  4  3  4  3  4  3  3  3  3
~~~

### Simulation Performance

The implementations here could be wrong or decision trees not actually optimal like we claimed.
We can test it by directly comparing the performance in a simulation of the coin-flipping game, comparing the performance of `mVPplan` vs the 20% Kelly criterion and a simple bet-everything strategy:

~~~{.R}
game <- function(strategy, wealth, betsLeft) {
    if (betsLeft>0) {
    bet <- strategy(wealth, betsLeft)
    wealth <- wealth - bet
    flip <- rbinom(1,1,p=0.6)
    winnings <- 2*bet*flip
    wealth <- min(wealth+winnings, 250)
    return(game(strategy, wealth, betsLeft-1)) } else { return(wealth); } }
simulateGame <- function(s, w=25, b=300) { replicate(5000, game(s, w, b)) }

kelly <- function(w, b) { 0.20 * w }
smarterKelly <- function(w, b) { if(w==(250*0.8)) {0} else { (2*0.6-1) * w } }

maximizer <- function(w, b) { w; }
smarterMaximizer <- function(w, b) { if(w>=250) { 0 } else {w}; }

# mean(simulateGame(smarterKelly, b=300) == 250)
# mean(simulateGame(mVPplan, b=300) == 250)

sapply(1:300, function(bets) {
    ky <- round(mean(simulateGame(smarterKelly, b=bets)), digits=1)
    dt <- round(mean(simulateGame(mVPplan, b=bets)), digits=1)
    gain <- dt-ky;
    print(paste(bets, mV(25, bets), dt, ky, gain)) })
# [1] "1 30 29.8 26.1 3.7"
# [1] "2 36 36.1 27 9.1"
# [1] "3 43.2 42.5 28.1 14.4"
# [1] "4 45.36 47.9 29.2 18.7"
# [1] "5 47.952 48.5 30.1 18.4"
# [1] "6 53.6544 51.7 31.7 20"
# [1] "7 54.58752 52.8 32.6 20.2"
# [1] "8 57.573504 57.4 34 23.4"
# [1] "9 61.8285312 61.5 35.1 26.4"
# [1] "10 62.6048870400001 59.6 36.8 22.8"
# [1] "11 66.761376768 66.4 38.5 27.9"
# [1] "12 68.2233145344 69.2 39.1 30.1"
# [1] "13 70.6011133132801 72.1 41.1 31"
# [1] "14 74.132982964224 74.9 43 31.9"
# [1] "15 74.9966063604204 75.8 44.6 31.2"
# [1] "16 79.0964893994582 77.4 46.3 31.1"
# [1] "17 79.745767264184 76.7 47.7 29"
# [1] "18 82.4937777791066 81.5 49.3 32.2"
# [1] "19 84.7111727297459 82.9 50.8 32.1"
# [1] "20 86.2422294497396 85.5 54.1 31.4"
# [1] "21 89.7571250817201 90.7 55.8 34.9"
# [1] "22 90.2656030147463 89.9 56.1 33.8"
# [1] "23 93.7598308377194 92 59.3 32.7"
# [1] "24 94.4756292069395 94.7 60.4 34.3"
# [1] "25 96.9586043002355 95.2 61.7 33.5"
# [1] "26 98.8072243859105 97.7 63.2 34.5"
# [1] "27 100.342755213062 103.7 65.3 38.4"
# [1] "28 103.187812527613 104.3 67.5 36.8"
# [1] "29 103.904006215225 105.8 69.5 36.3"
# [1] "30 107.174887230813 107.1 69.5 37.6"
# [1] "31 107.591476375961 110 72.6 37.4"
# [1] "32 110.306331782942 108.4 73.8 34.6"
# [1] "33 111.364071068843 112.2 74.2 38"
# [1] "34 113.291137173098 115.1 76.4 38.7"
# [1] "35 115.18603026538 113.7 78.6 35.1"
# [1] "36 116.393338891007 116.4 79.9 36.5"
# [1] "37 118.958126679847 118.7 81 37.7"
# [1] "38 119.595734910696 120 82.9 37.1"
# [1] "39 122.373631028947 122.2 83.8 38.4"
# [1] "40 122.868903994981 124.2 84.7 39.5"
# [1] "41 125.313911495719 126.9 84.8 42.1"
# [1] "42 126.188161205277 126.2 86.5 39.7"
# [1] "43 128.052213724493 127.6 87.1 40.5"
# [1] "44 129.528984874852 129.7 91.5 38.2"
# [1] "45 130.809560245159 130.1 92.6 37.5"
# [1] "46 132.829610284383 133.3 91.3 42"
# [1] "47 133.627232405131 135.3 93.4 41.9"
# [1] "48 135.954820828214 133.5 94.9 38.6"
# [1] "49 136.491477313108 139.7 95.8 43.9"
# [1] "50 138.78838922428 140.6 97.6 43"
# [1] "51 139.385048897764 141 99.2 41.8"
# [1] "52 141.369663251598 143.1 98.1 45"
# [1] "53 142.288401852145 143 100.7 42.3"
# [1] "54 143.83572425945 140.6 100.7 39.9"
# [1] "55 145.166648432423 143.4 103.9 39.5"
# [1] "56 146.29020723799 143.5 103.5 40"
# [1] "57 147.96514380167 148.6 106.1 42.5"
# [1] "58 148.769191880868 148.9 107.3 41.6"
# [1] "59 150.624832041202 150.9 107.9 43"
# [1] "60 151.271752873964 152.4 107.5 44.9"
# [1] "61 153.11651319205 152.9 110.6 42.3"
# [1] "62 153.786065432182 155.2 110 45.2"
# [1] "63 155.456910374596 154.3 111.7 42.6"
# [1] "64 156.299722913478 156.5 113 43.5"
# [1] "65 157.695449871744 155.4 114 41.4"
# [1] "66 158.790607536292 154.9 116.4 38.5"
# [1] "67 159.887684442714 161.1 115.2 45.9"
# [1] "68 161.225450543295 160.8 116.5 44.3"
# [1] "69 162.06023751337 163.4 118.2 45.2"
# [1] "70 163.56713597525 167.3 117.8 49.5"
# [1] "71 164.226994014538 168 120.4 47.6"
# [1] "72 165.791389797547 164.7 119.4 45.3"
# [1] "73 166.390385785777 167 121.3 45.7"
# [1] "74 167.897283254261 166.8 121.2 45.6"
# [1] "75 168.547304242229 167.3 123.2 44.1"
# [1] "76 169.906733155737 170.4 123.6 46.8"
# [1] "77 170.68664646264 168.9 125.2 43.7"
# [1] "78 171.847364270914 171.6 125.9 45.7"
# [1] "79 172.79017224444 172.5 124.6 47.9"
# [1] "80 173.742939786333 170.9 125.3 45.6"
# [1] "81 174.838600850521 176 129.3 46.7"
# [1] "82 175.610588354396 175.2 128.6 46.6"
# [1] "83 176.815379110305 178.1 128.8 49.3"
# [1] "84 177.462911167847 176 129.8 46.2"
# [1] "85 178.711599014751 180.3 128.3 52"
# [1] "86 179.302320243395 177.3 130 47.3"
# [1] "87 180.528025121038 180.2 130.8 49.4"
# [1] "88 181.1292789946 180 131 49"
# [1] "89 182.272185591958 183.3 133.2 50.1"
# [1] "90 182.936970887781 183.9 134.5 49.4"
# [1] "91 183.955996588401 184.8 133.2 51.6"
# [1] "92 184.712945446502 183.5 138.9 44.6"
# [1] "93 185.59211640418 187.7 136.7 51"
# [1] "94 186.446553783715 186 138.9 47.1"
# [1] "95 187.192978371388 188.3 138.4 49.9"
# [1] "96 188.129134357052 189 138.5 50.5"
# [1] "97 188.767797645908 188.7 140.5 48.2"
# [1] "98 189.754997706012 191.3 138.4 52.9"
# [1] "99 190.324345881518 190.4 138.8 51.6"
# [1] "100 191.322117926215 191 140.7 50.3"
# [1] "101 191.861799533876 196.2 139.3 56.9"
# [1] "102 192.832040659037 194 142.6 51.4"
# [1] "103 193.378954969471 193.4 144.3 49.1"
# [1] "104 194.289254855311 194 145.6 48.4"
# [1] "105 194.870985515173 196.2 144.5 51.7"
# [1] "106 195.700093491102 194.4 145.3 49.1"
# [1] "107 196.333693095267 196.6 145.8 50.8"
# [1] "108 197.071345163371 198 145.2 52.8"
# [1] "109 197.760628011314 199.5 147.6 51.9"
# [1] "110 198.410407288096 199.2 147.2 52"
# [1] "111 199.147338764714 199.3 148.3 51"
# [1] "112 199.722873427241 201.7 146.3 55.4"
# [1] "113 200.491283831353 198.2 150.9 47.3"
# [1] "114 201.01282000981 203 149 54"
# [1] "115 201.791908090659 200.2 150.9 49.3"
# [1] "116 202.284431237116 203 151.5 51.5"
# [1] "117 203.049997767406 203.5 151.3 52.2"
# [1] "118 203.536740965539 203.4 151.8 51.6"
# [1] "119 204.267769354554 205.4 153.5 51.9"
# [1] "120 204.765509267253 204.7 152.6 52.1"
# [1] "121 205.4485532138 205.6 153.7 51.9"
# [1] "122 205.967576289195 205.7 155.1 50.6"
# [1] "123 206.596039109649 206.9 153.1 53.8"
# [1] "124 207.14055668989 208.6 155.1 53.5"
# [1] "125 207.713851174434 206.4 154.6 51.8"
# [1] "126 208.28225523043 206.2 153.9 52.3"
# [1] "127 208.805183362864 207.1 154.2 52.9"
# [1] "128 209.391325457937 210.8 157.4 53.4"
# [1] "129 209.872631389946 208.9 154.5 54.4"
# [1] "130 210.467439410815 211 158.3 52.7"
# [1] "131 210.918576770617 210.1 155.9 54.2"
# [1] "132 211.511250602184 210.9 157.9 53"
# [1] "133 211.944180716757 213.4 157.2 56.2"
# [1] "134 212.524040614443 212 159 53"
# [1] "135 212.950049532397 214.3 157.2 57.1"
# [1] "136 213.507238153557 214.8 159.2 55.6"
# [1] "137 213.934910465079 214.3 158.5 55.8"
# ...
~~~

So the decision tree *does* outperform the 20% KC, and not by trivial amounts either for many possible _b_s, either in relative or absolute terms.
The decision tree doesn't require the full _b_=300 to nearly hit the ceiling, although the KC will.
However, the performance edge goes down as the horizon gets more distant, and we'll see that as far out as _b_=300, the advantage shrinks to ~\$6 as the ceiling is hit almost all the time by decent strategies (as we know from Haghani & Dewey 2016's analysis that KC hits the ceiling ~95% of the time with _b_=300, although of course it will do so far less often for shorter runs like _b_=50).

### Optimizing

The foregoing is interesting but the R implementation is too slow to examine the case of most importance: _b_=300.
The issue is not so much the intrinsic difficulty of the problem - since the R implementation's RAM usage is moderate even at _b_=150, indicating that the boundary conditions do indeed tame the exponential growth & turn it into something more like quadratic growth - but the slowness of computing.
Profiling suggests that most of the time is spent inside `memoise`:

~~~{.R}
# redefine to clear out any existing caching:
forget(mV)
Rprof(memory.profiling=TRUE, gc.profiling=TRUE, line.profiling=TRUE)
mV(w=25, b=9)
Rprof(NULL)
summaryRprof()
~~~

Most of the time is spent in functions which appear nowhere in our R code, like `lapply` or `deparse`, which points to the behind-the-scenes `memoise`.
Memoization *should* be fast because the decision tree can be represented as nothing but a multidimensional array in which one does lookups for each combination of _w_/_b_ for a stored value _V_, and array lookups ought to be near-instantaneous.
But apparently there is enough overhead to dominate our decision tree's computation.

We can switch to a compiled language with fast arrays.

#### Haskell

Implementations in Haskell have been written by Gurkenglas & nshepperd using [`array-memoize`](https://hackage.haskell.org/package/array-memoize) & [`Data.Vector`](https://hackage.haskell.org/package/vector) (respectively):

~~~{.Haskell}
import System.Environment (getArgs)
import Data.Function (iterate)
import Data.Function.ArrayMemoize (arrayMemo)

type Wealth = Int
type EV = Double

cap :: Wealth
cap = 250

value :: [Wealth -> EV]
value = iterate f fromIntegral where
  f next = arrayMemo (0, cap) $ \x -> maximum [go w | w <- [0..min (cap - x) x]] where
    go w = 0.6 * next (min cap (x+w)) + 0.4 * next (x-w)

main :: IO ()
main = do [x, b] <- map read <$> getArgs
          print $ value !! b $ x
~~~


~~~{.Haskell}
import System.Environment (getArgs)
import Data.Function (fix)
import Data.Function.Memoize (memoFix2)
import Data.Vector (Vector)
import qualified Data.Vector as V (generate, (!))

type Wealth = Int
type Bets = Int
type EV = Double

cap :: Wealth
cap = 250

value :: (Wealth -> Bets -> EV) -> Wealth -> Bets -> EV
value next 0 b = 0
value next w 0 = fromIntegral w
value next w b = maximum [go x | x <- [0..min (cap - w) w]]
  where
    go x = 0.6 * next (min cap (w+x)) (b-1) + 0.4 * next (w-x) (b-1)

-- Direct recursion.
direct :: Wealth -> Bets -> EV
direct = fix value

-- Memoised recursion.
memo :: Wealth -> Bets -> EV
memo w b = cached_value w b
  where
    cached_value w b = table V.! b V.! w
    table :: Vector (Vector EV)
    table = V.generate (b + 1)
            (\b -> V.generate (cap + 1)
              (\w -> value cached_value w b))

-- Memoised recursion using 'memoize' library; slower.
memo2 :: Wealth -> Bets -> EV
memo2 = memoFix2 value

main :: IO ()
main = do [w, b] <- map read <$> getArgs
          print (memo w b)
~~~

The second one is more low-level and uses laziness/"tying the knot" to implement the memoization; it is the fastest and is able to evaluate `memo 25 300` in <12s: the value turns out to be \$246.
(If we assume that all games either end in \$250 or \$0, then this implies that $\frac{246}{250} = 0.984$ or >98.4% of decision-tree games hit the max, as compared to Haghani & Dewey's estimate that ~95% of KC players would.)
The memoization is done internally, so to access all values we do more logic within the lexical scope.
We can obtain all values with a function like

~~~{.Haskell}
memo3 :: [Wealth] -> [Bets] -> [EV]
memo3 ws bs = zipWith cached_value ws bs
  where
    cached_value w b = table V.! b V.! w
    table :: Vector (Vector EV)
    table = V.generate (maximum bs + 1)
            (\b -> V.generate (cap + 1)
              (\w -> value cached_value w b))
~~~

and evaluate:

~~~{.Haskell}
λ> map round (memo3 (repeat 25) [1..300])
-- [30,36,43,45,48,54,55,58,62,63,67,68,71,74,75,79,80,82,85,86,90,90,94,94,97,99,100,
-- 103,104,107,108,110,111,113,115,116,119,120,122,123,125,126,128,130,131,133,134,
-- 136,136,139,139,141,142,144,145,146,148,149,151,151,153,154,155,156,158,159,160,
-- 161,162,164,164,166,166,168,169,170,171,172,173,174,175,176,177,177,179,179,181,
-- 181,182,183,184,185,186,186,187,188,189,190,190,191,192,193,193,194,195,196,196,
-- 197,198,198,199,200,200,201,202,202,203,204,204,205,205,206,207,207,208,208,209,
-- 209,210,210,211,212,212,213,213,214,214,214,215,215,216,216,217,217,218,218,219,
-- 219,219,220,220,221,221,221,222,222,222,223,223,224,224,224,225,225,225,226,226,
-- 226,227,227,227,228,228,228,228,229,229,229,230,230,230,230,231,231,231,231,232,
-- 232,232,232,233,233,233,233,234,234,234,234,234,235,235,235,235,236,236,236,236,
-- 236,236,237,237,237,237,237,238,238,238,238,238,238,239,239,239,239,239,239,239,
-- 240,240,240,240,240,240,240,241,241,241,241,241,241,241,241,242,242,242,242,242,
-- 242,242,242,242,243,243,243,243,243,243,243,243,243,243,244,244,244,244,244,244,
-- 244,244,244,244,244,244,245,245,245,245,245,245,245,245,245,245,245,245,245,245,
-- 246,246,246,246,246,246,246,246,246,246,246,246,246]
~~~

### Exact value function

We could go even further with `zip [1..3000] (memo3 (repeat 25) [1..3000])` (which takes ~118s).
Interestingly, the value stops increasing around _b_=2150 (_V_=249.99009946798637) and simply repeats from there; it does not actually reach 250.

This is probably because with a stake of \$25 it is possible to go bankrupt ([gambler's ruin](!Wikipedia)) even betting the minimal fixed amount of \$1.
(The original Haskell code is modeled after the R, which discretized this way for tractability; however, since the Haskell code is so fast, this is now unnecessary.)
If this is the case, then being able to bet smaller amounts should allow expected value to converge to \$250 as exactly as can be computed, because the probability of going bankrupt after 2500 bets of \$0.01 each is effectively zero - as far as R and Haskell will compute without special measures, $0.4^{2500}=0$.
We can go back and model the problem exactly as it was in the paper by simply multiply everything by 100 & interpreting in pennies:

~~~{.Haskell}
cap = 25000 -- 250*100
-- ...
λ> zip [1..3000] (memo3 (repeat (25*100)) [1..3000])
[(1,3000.0),(2,3600.0),(3,4320.0),(4,4536.000000000002),(5,4795.200000000003),
 (6,5365.440000000002),(7,5458.752000000004),(8,5757.350400000005),(9,6182.853120000005),(10,6260.488704000007),
 (11,6676.137676800007),(12,6822.331453440009),(13,7060.11133132801),(14,7413.298296422411),(15,7499.673019514893),
 (16,7913.219095166989),(17,7974.777338678492),(18,8250.07680018581),(19,8471.445742115113),(20,8625.387566014524),
 (21,8979.7747405993),(22,9028.029532170909),(23,9384.523360172316),(24,9449.401095461177),(25,9699.670042282964),
 (26,9882.821122181414),(27,10038.471393315525),(28,10323.078038637072),(29,10394.862038743217),(30,10760.507349554608),
 (31,10763.85850433795),(32,11040.414570571116),(33,11141.364854687306),(34,11337.607662912955),(35,11524.013477359924),
 (36,11648.117264906417),(37,11909.035644688667),(38,11968.56153182668),(39,12294.156320547045),(40,12296.062638839443),
 (41,12554.172237535688),(42,12628.174503649356),(43,12820.701630209007),(44,12962.820770637838),(45,13095.979243218648),
 (46,13298.241837094192),(47,13377.799870378874),(48,13632.949691989288),(49,13664.245374230446),(50,13935.591599024072),
 (51,13953.650302164471),(52,14168.318904539414),(53,14244.57145315508),(54,14407.574739209653),(55,14535.761032800987),
 (56,14651.76990919319),(57,14826.143029982914),(58,14899.500923102909),(59,15114.7924517843),(60,15149.530755496799),
 (61,15399.983335449066),(62,15400.771450460255),(63,15604.908915203496),(64,15652.268440952908),(65,15813.476931576255),
 (66,15903.186446379666),(67,16025.159151461572),(68,16152.79680966944),(69,16238.976728976708),(70,16400.466139297678),
 (71,16454.05880056233),(72,16645.646128447275),(73,16669.63235112316),(74,16880.735724497223),(75,16885.012958972715),
 (76,17058.916142797243),(77,17099.596358241968),(78,17239.339510457277),(79,17312.850756552616),(80,17421.275332110683),
 (81,17524.309847338853),(82,17604.068867939182),(83,17733.56645905442),(84,17787.13463287746),(85,17940.266786525535),
 (86,17969.95038247786),(87,18144.105153480315),(88,18152.051576292564),(89,18315.336828409476),(90,18333.026286703964),
 (91,18467.997509430665),(92,18512.510521892633),(93,18621.43451689773),(94,18690.183932686265),(95,18775.180977557586),
 (96,18865.765874427907),(97,18928.817685066606),(98,19039.0117965317),(99,19081.969208988696),(100,19209.70993405155),
 (101,19234.300290845116),(102,19377.678277281033),(103,19385.51250899971),(104,19524.210291319585),(105,19535.341194745335),
 (106,19651.63659936918),(107,19683.55258264968),(108,19779.19175398216),(109,19829.94117896368),(110,19906.559349360658),
 (111,19974.327332744302),(112,20033.4549154762),(113,20116.554995203987),(114,20159.623419373274),(115,20256.489653646044),
 (116,20284.836941737507),(117,20394.01642719967),(118,20408.892517902153),(119,20529.038285622184),(120,20531.61013289084),
 (121,20639.865300258658),(122,20652.830860566657),(123,20744.14900653099),(124,20772.415137446053),(125,20848.093322557295),
 (126,20890.24116222975),(127,20951.49506668366),(128,21006.203412595118),(129,21054.171837601196),(130,21120.21127127963),
 (131,21155.960430614512),(132,21232.187753960352),(133,21256.71536121999),(134,21342.06833189189),(135,21356.30748944987),
 (136,21449.7998427048),(137,21454.622738748447),(138,21545.893033861896),(139,21551.56090345761),(140,21629.60553083633),
 (141,21647.034539300425),(142,21712.842497605183),(143,21740.96793155338),(144,21795.467123757197),(145,21833.2961358927),
 (146,21877.356736609778),(147,21923.964087187007),(148,21958.401746908596),(149,22012.92577178374),(150,22038.504663866137),
 (151,22100.143459100647),(152,22117.579175397976),(153,22185.586988586107),(154,22195.549289624447),(155,22269.23310835155),
 (156,22272.348533907876),(157,22343.200726693787),(158,22347.9192078922),(159,22408.92268721723),(160,22422.211687202966),
 (161,22474.09110290414),(162,22495.183774650206),(163,22538.619509420547),(164,22566.800095953415),(165,22602.430698828903),
 (166,22637.031537177958),(167,22665.456036220217),(168,22705.854721234122),(169,22727.634820414445),(170,22773.2515209447),
 (171,22788.913686133077),(172,22839.208606334214),(173,22849.246045182404),(174,22903.71702393249),(175,22908.591564315902),
 (176,22966.44249475668),(177,22966.915677569094),(178,23017.91541566918),(179,23024.18913098028),(180,23068.1913376925),
 (181,23080.387557725626),(182,23117.90218718125),(183,23135.491081806776),(184,23166.99717629234),(185,23189.48394853381),
 (186,23215.431334191013),(187,23242.35418014611),(188,23263.165077204263),(189,23294.093255008785),(190,23310.163806371635),
 (191,23344.695808912184),(192,23356.397530793947),(193,23394.159357087876),(194,23401.840515265318),(195,23442.484035635396),
 (196,23446.47095075504),(197,23489.640293583914),(198,23490.270646383346),(199,23529.46834312825),(200,23533.224741609163),
 (201,23567.312697440484),(202,23575.321437418483),(203,23604.666095269786),(204,23616.551745369172),(205,23641.497567737664),
 (206,23656.90925341186),(207,23677.779921209272),(208,23696.38990746728),(209,23713.489458166325),(210,23734.991807798215),
 (211,23748.60571568506),(212,23772.71501926872),(213,23783.111220502426),(214,23809.56139463541),(215,23816.991259707916),
 (216,23845.534410064567),(217,23850.233666149958),(218,23880.639012115425),(219,23882.82861769509),(220,23914.391375329913),
 (221,23914.76844952492),(222,23942.714790600083),(223,23946.0474787004),(224,23970.438187949254),(225,23976.66184026535),
 (226,23997.74934793851),(227,24006.60933420138),(228,24024.631040582935),(229,24035.889282584474),(230,24051.068374275732),
 (231,24064.50239633),(232,24077.048621078735),(233,24092.450650947027),(234,24102.561052984205),(235,24119.737170755707),
 (236,24127.59678851838),(237,24146.366121052237),(238,24152.148649090945),(239,24172.342607735227),(240,24176.211024526496),
 (241,24197.672583935127),(242,24199.779747244538),(243,24222.35471729034),(244,24222.851974583486),(245,24243.93438158678),
 (246,24245.42607879143),(247,24263.972996501543),(248,24267.50154423283),(249,24283.6900658947),(250,24289.078871384656),
 (251,24303.07565677869),(252,24310.159487219513),(253,24322.121319078917),(254,24330.74566159496),(255,24340.819980440137),
 (256,24350.840429290023),(257,24359.165841053073),(258,24370.447517349417),(259,24377.154275094566),(260,24389.571277415347),
 (261,24394.781738403053),(262,24408.216622744527),(263,24412.045682031203),(264,24426.388969625325),(265,24428.94447133704),
 (266,24444.09418292577),(267,24445.477310292874),(268,24461.32346887292),(269,24461.644170708976),(270,24476.42136455785),
 (271,24477.445726085083),(272,24490.501181704694),(273,24492.883289818776),(274,24504.335944986862),(275,24507.958757514363),
 (276,24517.920620087607),(277,24522.6745531501),(278,24531.251041416166),(279,24537.03357887482),(280,24544.32387659046),
 (281,24551.039168217816),(282,24557.136561611253),(283,24564.69504250772),(284,24569.687240115927),(285,24578.005270307505),
 (286,24581.974706479406),(287,24590.97422968356),(288,24593.998352542163),(289,24603.606573136858),(290,24605.75811775705),
 (291,24615.907195034095),(292,24617.254442557904),(293,24627.881197714756),(294,24628.488224763427),(295,24639.274079225856),
 (296,24639.46077884001),(297,24649.128469095107),(298,24650.173797856685),(299,24658.72751316172),(300,24660.629317974468)
 ...
 (1884,24999.999999999614),(1885,24999.99999999963),(1886,24999.999999999643),(1887,24999.999999999658),(1888,24999.99999999967),
 (1889,24999.99999999968),(1890,24999.999999999694),(1891,24999.9999999997),(1892,24999.999999999716),(1893,24999.999999999727),
 (1894,24999.999999999738),(1895,24999.99999999975),(1896,24999.99999999976),(1897,24999.999999999767),(1898,24999.99999999978),
 (1899,24999.99999999979),(1900,24999.9999999998),(1901,24999.99999999981),(1902,24999.999999999818),(1903,24999.999999999825),
 (1904,24999.999999999833),(1905,24999.999999999844),(1906,24999.999999999854),(1907,24999.99999999986),(1908,24999.99999999987),
 (1909,24999.999999999876),(1910,24999.999999999884),(1911,24999.99999999989),(1912,24999.999999999898),(1913,24999.999999999905),
 (1914,24999.999999999913),(1915,24999.99999999992),(1916,24999.999999999924),(1917,24999.999999999927),(1918,24999.999999999935),
 (1919,24999.99999999994),(1920,24999.99999999995),(1921,24999.99999999995),(1922,24999.999999999956),(1923,24999.999999999964),
 (1924,24999.999999999967),(1925,24999.99999999997),(1926,24999.999999999978),(1927,24999.999999999978),(1928,24999.999999999985),
 (1929,24999.99999999999),(1930,24999.999999999993),(1931,24999.999999999993),(1932,25000.0),(1933,25000.0),
 (1934,25000.0),(1935,25000.0),(1936,25000.0),(1937,25000.0),(1938,25000.0),
 (1939,25000.0),(1940,25000.0),(1941,25000.0),(1942,25000.0),(1943,25000.0),
 (1944,25000.0),(1945,25000.0),(1946,25000.0),(1947,25000.0),(1948,25000.0),
 (1949,25000) ... ]
~~~~

With the exact penny version, the value of _b_=300 is now \$246.6062932 (taking ~3746s compiled), so the approximation costs an expected value of only \$0.61.
The full run reveals that convergence happens at  _b_=1932 (which can be computed in ~48503s compiled), past which there is no need to compute further.

#### Exact formula

[Arthur B. notes](https://twitter.com/ArthurB/status/823241996244422656) that "you can compute $U(w,b)$ in $O(b)$ if you allow bets to be any fraction of _w_. It's piecewise linear, the cutoff points and slopes follow a very predictable pattern" and provides a formula for calculating the value function without constructing a decision tree:

$$
250\left(\frac{6}{5}\right)^b \left(\frac{w}{250} - \frac{1}{3}\sum_{k=0}^{b-1}\left(\frac{2}{3}\right)^k\max\!\left(\frac{w}{250}-\frac{1}{2^b}\sum_{j=0}^{k}\binom{b}{j},~0\right)\right)
$$

(I tried implementing it in R but may not have gotten it right.[^formula])

[^formula]: As:

    ~~~{.R}
    function(w,b) { (250 * (6/5)^b) *
        ((w/250) - (1/3)*sum(sapply(0:(b-1), function(k) { (2/3)^k * max((w/250) - (1/(2^b)) *
            sum(sapply(0:k, function(j) { choose(b, j)})), 0) }))) }
    ~~~

    But comparing this to the decision-trees, it doesn't quite work, as while it's correct for a number of values, it goes well past the \$250 ceiling. The fault might be in the R implementation of the binomial coefficients, `choose`, not working the same as in Mathematica.
